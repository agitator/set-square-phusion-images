#!/bin/bash
# (c) 2008-today Automated Computing Machinery, S.L.
#
#    This file is part of dry-wit.
#
#    dry-wit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    dry-wit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with dry-wit.  If not, see <http://www.gnu.org/licenses/>.

#set -o errexit  # terminate on any unhandled error
#set -o nounset  # terminate on any unset variable

# IFS stuff
_OLD_IFS="${IFS}";
export IFS=$'\n\t\040';

export SCRIPT_INTERRUPTED="User interruption";
export MISSING_MANDATORY_VARIABLES=\
"Script not complete, since it doesn't define all mandatory variables";
export MISSING_MANDATORY_FUNCTIONS=\
"Script not complete, since it doesn't define all mandatory functions";
export UNKNOWN_ERROR=\
"The script has finished due to an unexpected error";

export BUILTIN_ERRORS=(\
    SCRIPT_INTERRUPTED \
    MISSING_MANDATORY_VARIABLES \
    MISSING_MANDATORY_FUNCTIONS \
    UNKNOWN_ERROR \
  );

export _CLEANUP_FILES=(\
  );

export BUILTIN_SUCCESS_KEYWORDS=(\
  "Success" \
  "Done" \
  "Ok" \
  );

export BUILTIN_FAILURE_KEYWORDS=(\
  "Error" \
  "Failure" \
  "Ko" \
  );

#export SUCCESS_KEYWORDS;
#export FAILURE_KEYWORDS;

export SUCCESS=0;
export FAILURE=1;
export IN_PROGRESS=2;
export TRUE=0;
export FALSE=1;
export UNDEFINED=255;

export _DRY_WIT_LOG_STACK=();
export _DRY_WIT_LOG_CATEGORY_STACK=();
export _DRY_WIT_LOG_LEVEL_STACK=();
export _DRY_WIT_LOG_OUTCOME_TOKENS=();
export _DRY_WIT_LOG_OUTCOME_COLORS=();
export _DRY_WIT_DEFAULT_TERM_WIDTH=80;
export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
export NESTED_TASK_IN_PROGRESS="....";

export LOG_TIMESTAMP="+%Y/%m/%d %H:%M:%S";
export LOG_OUTCOME_SEPARATOR=" ";
export LOG_NESTED_INDENTATION="  ";

## PUBLIC
## Checks whether given value is empty.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isEmpty "${MYVAR}"; then echo "MYVAR is empty"; fi
function isEmpty() {
  local _rescode;
  if [ -z "${1}" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PUBLIC
## Checks whether given value is defined.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isDefined "${MYVAR}"; then echo "MYVAR is defined"; fi
function isDefined() {
    local _rescode;
    if [ -z ${1+x} ]; then
      _rescode=${TRUE};
    else
        _rescode=${FALSE};
    fi
    return ${_rescode};
}

## PUBLIC
## Checks whether given variable is defined.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isDefined "${MYVAR}"; then echo "MYVAR is defined"; fi
function isVariableDefined() {
    local _rescode;
    eval "[ -v \${$1} ] 2> /dev/null"
    if [ $? -eq 0 ]; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
    return ${_rescode};
}

## PRIVATE/DEBUG
## Prints the contents of given array.
## -> 1: The name of the array.
## Example:
##   A=( "1" "2" "3" );
##   _dwDebugArray "${A}"
function __dwDebugArray() {
    flattenArray "${1}" " + ";
    echo "${RESULT}";
}

## PUBLIC
## Checks whether given value is true.
## -> 1: The value.
## <- 0: if the value is true; 1 otherwise.
function isTrue() {
  local _value="${1}";
  local _rescode;
  if [ "${_value}" == "${TRUE}" ]; then
    _rescode=${TRUE};
  elif [ "${_value}" == TRUE ]; then
    _rescode=${TRUE};
  elif [ "${_value}" == "true" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PUBLIC
## Checks whether given value is false.
## -> 1: The value.
## <- 0: if the value is false; 1 otherwise.
function isFalse() {
  local _rescode;
  if isTrue $*; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi
  return ${_rescode};
}

function _evalVar() {
  local _varName="${1}";
  local _result="$(set noglob; export DOLLAR='$'; export DQUOTE="\""; echo "echo ${DQUOTE}${DOLLAR}{$(echo "${_varName}")}${DQUOTE}" | sh)";
  export RESULT="${_result}";
}

function defineEnvVar() {
  local _varName="${1}";
  local _varDescription="${2}";
  local _varDefault="${3}";
  local _varCommand="${4}";

  local _varValue="$(echo 'echo $'$(echo ${_varName}) | sh)";

  if [[ -n ${_varDescription} ]]; then
    _evalVar "${_varName}_DESCRIPTION";
    local _description="${RESULT}";

    if [[ ! -n ${_description} ]]; then
      export ${_varName}_DESCRIPTION="${_varDescription}";
    fi
  fi

  if [[ -n ${_varDefault} ]]; then
    _evalVar "${_varName}_DEFAULT";
    local _defaultValue="${RESULT}";
    _defaultValue="${_varDefault}";
  fi

  if [[ -n ${_defaultValue} ]]; then
    export ${_varName}_DEFAULT="${_defaultValue}";
    _evalVar "${_varName}_DEFAULT";
  fi


  _addEnvVar "${_varName}";

  if [[ -n ${_varCommand} ]]; then
#    echo -n "${_varName}_DEFAULT_COMMAND->${_varCommand}";
    _evalVar "${_varName}_DEFAULT_COMMAND";
    local _command="${RESULT}";
#    echo "${_command}";
    if [[ ! -n ${_command} ]]; then
      export ${_varName}_DEFAULT_COMMAND="${_varCommand}";
    fi
    _evalVar "${_varName}_DEFAULT_COMMAND";
    local _command="${RESULT}";
  fi
}

function overrideEnvVar() {
  local _varName="${1}";
  local _varDefault="${2}";

  defineEnvVar "${_varName}" "" "${_varDefault}" "";
  _evalEnvVar ${_varName};
}

function _addEnvVar() {
  local _varName="${1}";
  if ! _isEnvVarDefined "${_varName}"; then
    ENV_VARIABLES=(\
        ${ENV_VARIABLES[@]} \
        ${_varName} \
    );
    export ${_varName};
    export ENV_VARIABLES;
  fi
}

function _isEnvVarDefined() {
    local _varName="${1}";
    local e;
    for e in "${ENV_VARIABLES[@]}"; do [[ "${e}" == "${_varName}" ]] && return 0; done
    return 1;
}

function _evalEnvVar() {
  local _varName="${1}";
  _evalVar "${_varName}_DEFAULT";
  local _defaultValue="${RESULT}";
  _evalVar "${_varName}";
  local _varValue="${RESULT}";

  if [[ ! -n ${_varValue} ]]; then
    if [[ -n ${DRY_WIT_EVAL_DEFAULTS_FLAG} ]]; then
#      echo -n "Evaluating ${_varName}_DEFAULT_COMMAND -> ";
      _evalVar "${_varName}_DEFAULT_COMMAND";
      local _defaultCommand="${RESULT}";
#      echo "${_defaultCommand}";
      if [[ -n ${_defaultCommand} ]]; then
        logTrace -n "Resolving ${_varName}_DEFAULT via ${_varName}_DEFAULT_COMMAND"
        local _aux="$(set noglob; echo "${_defaultCommand}" | sh)";
        if [[ -n ${_aux} ]]; then
          _defaultValue="${_aux}";
          logTraceResult SUCCESS "${_aux}"
        else
          logTraceResult FAILURE "failed"
        fi
      fi
    fi
    _varValue="${_defaultValue}";
  fi

  if [[ -n ${_varValue} ]] && [[ -z ${DRY_WIT_EVAL_DEFAULTS_FLAG} ]]; then
    while [[ "${_varValue}" =~ .*'$'.* ]]; do
      _varValue="$(set noglob; echo "echo ${_varValue}" | sh)";
    done
  fi

  if [[ -n ${_varValue} ]]; then
    export ${_varName}="${_varValue}";
  fi
}

function evalEnvVars() {
  for var in ${ENV_VARIABLES[@]}; do
    _evalEnvVar ${var};
  done
}

## PUBLIC
## Retrieves the value of a constant.
## -> 1: The constant name.
## <- RESULT: The constant value.
## Example:
##  _OTHERVAR="works"
##  _MYVAR="OTHERVAR";
##  evalConstant "${_MYVAR}";
##  echo "${_MYVAR}->${RESULT}" # _OTHERVAR->works
function evalConstant() {
    local _constant="${1}";

    local _result=$(echo | awk -v c="${_constant}" -v p1="{" -v p2="}" '{printf("echo %s%s%s%s\n", "$", p1, c, p2);}' | sh 2> /dev/null);

    if isEmpty "${_result}" ; then
      _result="${2}";
    fi

    if isEmpty "${_result}" ; then
      _result="${_constant}";
    fi
    #  if [ "${DEBUG}" == "1" ]; then
    #    echo "";
    #    echo "${_constant} converts to ${_result}";
    #  fi

    export RESULT="${_result}";
}

## PUBLIC
## Converts given |-separated text into an array (after
## sourcing a temporary file.
## -> 1: The name of the array variable to set.
## -> 2: The string with the "exported" array.
## <- RESULT: Either the empty string, if the array
##            already existed globally, or the name
##            of a temporary file to source to be able
##            to use the array, if it's new.
## Example:
##    pipe2Array "MY_ARRAY" "a|b and c|d";
##    source "${RESULT}";
##    echo "${MY_ARRAY[0]}" # a
##    echo "${MY_ARRAY[1]}" # b and c
##    echo "${MY_ARRAY[2]}" # d
function pipe2Array() {
  local _name="${1}";
  shift;
  if ! isVariableDefined "${_name}"; then
    declare -a "${_name}";
  fi

  if isVariableDefined "${_name}"; then
    _pipe2ExistingArray "${_name}" "$@";
  else
    echo "${_name} not defined"
    exit 1
    _pipe2ArrayWithTempFile "${_name}" "$@";
  fi
  export "${_name}";
}

## PRIVATE
## Updates the values of an array, with the given |-separated text.
## -> 1: The name of the array variable to update.
## -> 2: The string with the "exported" array.
## Example:
##    declare -a MY_ARRAY;
##    pipe2Array "MY_ARRAY" "a|b and c|d";
##    source "${RESULT}";
##    echo "${MY_ARRAY[0]}" # a
##    echo "${MY_ARRAY[1]}" # b and c
##    echo "${MY_ARRAY[2]}" # d
function _pipe2ExistingArray() {
  local _name="${1}";
  local _value="${2}";
  local -i _i=0;
  local _len=$(echo "${_value}" | sed 's/|/\n|\n/g' | grep -c '|');
  mapfile -t "${_name}" < <(echo "${_value}" | sed 's/|/\n/g' | sed 's/^\s+//g' | sed 's/\s+$//g' | sed 's/^"//g' | sed 's/"$//g');
#
#  local _oldIFS=$IFS
#  IFS=$(echo -en "\n\b")
#  local _valueLines="$(echo "${_value}" | sed 's/|/\n/g' | sed 's/^\s+//g' | sed 's/\s+$//g' | sed 's/^"//g' | sed 's/"$//g')";
#  eval "export ${_name}=();"
#  for _line in ${_valueLines}; do
#    eval "${_name}[${_i}]=\"${_line}\"";
#    echo "${_name}[${_i}]=\"${_line}\"";
#    _i=$((${_i}+1))
#  done
#  declare -a ${_name};
#  export ${_name};
#  # restore $IFS
#  IFS=${_oldIFS};
  export RESULT="";
}

## PRIVATE
## Converts given |-separated text into an array (after
## sourcing a temporary file.
## -> 1: The name of the array variable to set.
## -> 2: The string with the "exported" array.
## <- RESULT: Either the empty string, if the array
##            already existed globally, or the name
##            of a temporary file to source to be able
##            to use the array, if it's new.
## Example:
##    pipe2Array "MY_ARRAY" "a|b and c|d";
##    source "${RESULT}";
##    echo "${MY_ARRAY[0]}" # a
##    echo "${MY_ARRAY[1]}" # b and c
##    echo "${MY_ARRAY[2]}" # d
function _pipe2ArrayWithTempFile() {
  local _name="${1}";
  local _value="${2}";
  local _result="${3}";
  local _temp="";
  if isEmpty "${_result}"; then
    createTempFile;
    _result="${RESULT}";
    _temp="${4}";
  fi
  if isEmpty "${_temp}"; then
    createTempFile;
    _temp="${RESULT}";
  fi
  echo "declare -a ${_name};" >> ${_result};
  local -i _i=0;
  local _len=$(echo "${_value}" | sed 's/|/\n|\n/g' | grep -c '|');
  local _valueLines="$(echo "${_value}" | sed 's/|/\n/g' | sed 's/^\s+//g' | sed 's/\s+$//g' | sed 's/^"//g' | sed 's/"$//g')";
  echo "temp -> ${_temp}";
  cat <<EOF > ${_temp}
${_valueLines}
EOF
  for _i in $(seq 0 ${_len}); do
    echo "${_name}[${_i}]=\"$(cat -n "${_temp}" | grep -e "^\s*$((${_i} + 1))\s" | awk '{if (NF>1) {for (i=2;i<NF;i++) {printf("%s ", $i);}; printf("%s", $NF);}}';)\";" >> ${_result};
    _i=$((${_i}+1));
  done
  echo "export ${_name};" >> ${_result};

  export RESULT="${_result}";
}

## PUBLIC
## Flattens an array, using given separator.
## -> 1: The name of the array variable.
## -> 2: The separator to use.
## <- RESULT: The resulting string.
## Example:
##   A=(a b c);
##   _flattenArray A "x";
##   echo "A->${RESULT}" # axbxc
function flattenArray() {
  local _arrayName="${1}";
  local _separator="${2}";
  local _result="";

  local _aux="$(echo "\${#${_arrayName}[@]}")";
  local _len=$((-1+$(eval echo "${_aux}")));
  for _i in $(seq 0 ${_len}); do
    _aux="$(echo "\${${_arrayName}[${_i}]}")";
    _item=$(eval echo "${_aux}");
    _result="${_result}${_separator}${_item}";
  done
  _result="${_result#${_separator}}";
  export RESULT="${_result}";
}

# Checks whether a given flag is enabled
# -> 1: the name of the flag variable
# <- 0 if the flag is enabled, 1 otherwise.
# Example:
# function parseInput() {
# [..]
#   -my | --myFlag) export MY_FLAG=${TRUE};
#                   ;;
# [..]
# if _flagEnabled MY_FLAG; then
#    ..
function _flagEnabled() {
  local _flagVar="${1}";
  local _flagVal;
  local _result;
  _evalVar "${_flagVar}";
  _flagVal="${RESULT}";
  if [ "x${_flagVal}" == "x0" ]; then
      _result=${TRUE};
  else
      _result=1;
  fi
  return ${_result};
}

# AUXILIARY GENERAL-PURPOSE FUNCTIONS

function cleanup() {
  if [ "${#_CLEANUP_FILES}" != "0" ]; then
    setLogCategory "post-process";

    logDebug -n "Cleaning up temporary files";

    for i in ${_CLEANUP_FILES[*]}; do
      logTrace -n "Deleting $i";
      rm -rf $i > /dev/null;
      if [ $? -eq 0 ]; then
        logTraceResult SUCCESS "done";
      else
        logTraceResult FAILURE "failed";
      fi
    done

    logDebugResult SUCCESS "done";
  fi
  # restoring old IFS
  export IFS="${_OLD_IFS}";
}

function checkReq() {
  which $1 2>/dev/null > /dev/null;
  [ $? != 0 ] && exitWithErrorCode $2;
}

function createTempFile() {
  local _prefix="$(echo \"${SCRIPT_NAME}\" | awk -F"/" '{print $NF;}' | sed 's/^"//g' | sed 's/"$//g')";
  local _dirname="$(dirname \"${SCRIPT_NAME}\")";
#  local _prefix="$(echo "${SCRIPT_NAME}" | awk -F"/" '{print $NF;}')";
#  local _dirname="$(dirname "${SCRIPT_NAME}")";
  if [ "${_dirname#\.\.}" == "${_dirname}" ]; then
    _dirname="$PWD/${_dirname#\.}";
  else
    _dirname="$PWD/../${_dirname#\.\.}";
  fi
  local result="$(mktemp -p "${_dirname}"  -t ".${_prefix}.XXXXXXXXXX")";
  local _aux=$?;
  rm -f $result > /dev/null
  if [ $_aux -ne 0 ]; then
     result="$(mktemp -t ".${_prefix}.XXXXXXXXXX")";
     _aux=$?;
  fi
  if [ $_aux -ne 0 ]; then
     exitWithErrorCode $1;
  fi
  addFileToCleanup "${result}";

  export RESULT="${result}";
}

## Checks if given file is writeable
## -> 1: the file to check.
## <- 0: the file is writeable; 1 otherwise.
function fileIsWriteable() {
  local _file="${1}";
  if [[ -n ${_file} ]] && [[ -w ${_file} ]]; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

## Checks if an element is already contained in an array.
## -> [1]: The element to check
## -> [2]: The array (passed as "${array[@]}"
## <- 0: If the element is present in the array.
## <- 1: Otherwise
## Example:
##   a=("one" "two" "three" "other number")
##   if containsElement "other number" "${array[@]}"; then
##     ...
##   fi
function arrayContainsElement() {
  local _item="${1}";
  local _array="${2}";
  local _aux;
  for _aux in "${_array}"; do
    if [[ "${_aux}" == "${_item}" ]]; then
      return 0;
    fi
  done
  return 1;
}

function addFileToCleanup() {
  local _file="${1}";
#  logTrace "Appending ${result} to _CLEANUP_FILES";
  _CLEANUP_FILES=(\
    $(for i in ${_CLEANUP_FILES[*]}; do echo $i; done) \
      "${_file}" \
  );
}

function createTempFolder() {
  local _prefix="$(echo ${SCRIPT_NAME} | awk -F"/" '{print $NF;}')";
  local _dirname="$(dirname ${SCRIPT_NAME})";
  if [ "${_dirname#\.\.}" == "${_dirname}" ]; then
    _dirname="$PWD/${_dirname#\.}";
  else
    _dirname="$PWD/../${_dirname#\.\.}";
  fi
  local result=$(mktemp -p "${_dirname}" -d -t ".${_prefix}.XXXXXX");
  local _aux=$?;
  if [ $_aux -ne 0 ]; then
    result=$(mktemp -d -t ".${_prefix}.XXXXXX");
    _aux=$?;
  fi
  if [ $_aux -ne 0 ]; then
     exitWithErrorCode $1;
  fi
  addFileToCleanup "${result}";

  export RESULT="${result}";
}

function extractFlags() {
  local result="";
  echo " $@" \
    | awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' \
    | awk -F" " '{print $1;}'
}

function extractFlagValue() {
  local flag=$1;
  shift;
  echo " $@" \
    | awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' \
    | grep -e "^$flag " \
    | awk -v f="${flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' \
    | sh;
}

function logFlag() {
  local _flag="$1";
  local _value="$2";
  local _placeholders=$3;
  local _remaining="$4";

  if [ "x${_value}" != "x" ]; then
    _value=" ${_value}";
  fi
  if [ "x${_remaining}" != "x" ]; then
    _remaining=" Remaining ${_remaining}";
  fi
  logTrace "Parsed ${_flag} ${_value}. Shifting ${_placeholders} placeholder(s).${_remaining}";
}

function findInPath() {
  local _result="";
  local _paths="$(echo \"$PATH:.\" | awk -F":" '{for(i=1;i<=NF;i++) print $i;}')";
#  local _paths="$(echo "$PATH:." | awk -F":" '{for(i=1;i<=NF;i++) print $i;}')";
  for _path in $_paths; do
    if [ -f "${_path}/$1" ]; then
      _result="${_path}/$1";
      break;
    fi
  done
  echo ${_result};
}

function isSuccessKeyword() {
  local _keyword="${1}";
  local _result=1;

  if    [ "x${SUCCESS_KEYWORDS}" != "x" ] \
     && [  ${SUCCESS_KEYWORDS[*]} != "" ]; then
    for i in ${SUCCESS_KEYWORDS[*]}; do
      if    [ "x${i}" == "x${_keyword}" ] \
         || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
             == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#         || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#             == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi

  if [ ${_result} == 1 ]; then
    for i in ${BUILTIN_SUCCESS_KEYWORDS[*]}; do
      if [ "x${i}" == "x${1}" ] \
          || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
              == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#          || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#              == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi

  return ${_result};
}

function isFailureKeyword() {
  local _keyword="${1}";
  local _result=1;

  for i in ${FAILURE_KEYWORDS[*]}; do
    if    [ "x${i}" == "x${1}" ] \
       || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
           == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#      || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#           == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
      _result=${TRUE};
      break;
    fi;
  done

  if [ ${_result} != 0 ]; then
    for i in ${BUILTIN_FAILURE_KEYWORDS[*]}; do
      if [ "x${i}" == "x${1}" ] \
        || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
            == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#        || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#            == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi

  return ${_result};
}

function printErrorMessage() {
  local _result=${TRUE};
  local _message;
  local _error;
  local _interruption=${TRUE};

  for i in ${BUILTIN_ERRORS[*]}; do
    _result=$((_result+1));
    if [ "x${i}" == "x${1}" ]; then
      _message="$i";
      break;
    fi;
  done

  if [ "x${_message}" == "x" ]; then
    # IFS issue
#    _result=${TRUE};
    for i in ${ERROR_MESSAGES[*]}; do
      _result=$((_result+1));
      if [ "x${i}" == "x${1}" ]; then
        _message="$i";
        break;
      fi;
    done
  fi
  if [ "x${_message}" == "x" ]; then
    _error="Error $1, but no error message defined. Fix this script";
    _result=-1;
    shift;
  else
    shift;
    _error="$(echo ${_message} \
  | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh)";
#  | awk -v dollar="$" '{printf("echo \"%s{%s}\"\n", dollar, $0);}' | sh)";
  fi

  if [ ${#@} -gt 0 ]; then
    _error="${_error} ($@)";
  fi

  if [ ${_result} == 1 ]; then
    _error="${_error}. Finishing..";
  fi
  if isDebugEnabled; then
    _printUsage $SCRIPT_NAME;
  fi
  _printError "${_error}";

  return ${_result};
}

function exitWithErrorCode() {
  local _rescode;
  printErrorMessage $@;
  _rescode=$?;
  cleanup;
  exit ${_rescode};
}

# Internal functions

function _printError() {
  echo "Error: $@.";
}

function _printEnvironment() {
  if [ "x${ENV_VARIABLES[*]}" != "x" ] \
     && isTraceEnabled; then
    cat <<EOF
Environment variables:
EOF
    for ((i = 0; i < ${#ENV_VARIABLES[*]}; i++)); do
      echo "  ${ENV_VARIABLES[$i]} $(echo ${ENV_VARIABLES[$i]} | awk -v dollar="$" -v quote="\"" '{printf("echo %s(%s{%s}): %s{%s_DESCRIPTION}%s.\n", quote, dollar, $0, dollar, $0, quote);}' | sh)";
#      echo "  ${ENV_VARIABLES[$i]} $(echo ${ENV_VARIABLES[$i]} | awk -v dollar="$" -v quote="\"" '{printf("echo %s(%s%s%s{%s}): %s%s%s{%s_DESCRIPTION}%s%s.%s\n", quote, quote, quote, dollar, $0, quote, quote, dollar, $0, quote, quote, quote);}' | sh)";
    done
  fi
}

function _printExitValues() {
  local i;
  local j;
  if isTraceEnabled; then
    cat <<EOF
Exit values:
  0: No error.
EOF
    if [ "x${BUILTIN_ERRORS[*]}" != "x" ]; then
      for ((i = 0; i < ${#BUILTIN_ERRORS[*]}; i++)); do
        echo "  $((i+1)): $(echo ${BUILTIN_ERRORS[$i]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
    if [ "x${ERROR_MESSAGES[*]}" != "x" ]; then
      for ((j = 0; j < ${#ERROR_MESSAGES[*]}; j++)); do
        echo "  $((j+i+1)): $(echo ${ERROR_MESSAGES[$j]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
  fi
}

function _printHelp() {

  if _functionPresent defineEnv "${SCRIPT_NAME}"; then
    defineEnv;
  fi
  usage $SCRIPT_NAME;
  _printEnvironment;
  _printExitValues;
}

function _printUsage() {
  _printHelp >&2
}

function _trapSignals() {
  trap 'exitWithErrorCode SCRIPT_INTERRUPTED' INT QUIT TSTP
}

# Converts given date (in days) to a formatted date.
function jd2date() {

  local _standardJd;
  local _temp1;
  local _temp2;
  local _jd;
  local _year;
  local _month;
  local _day;

  local _jd=$1;

  _standardJd=$((_jd+2400001));
  _temp1=$((_standardJd+68569));
  _temp2=$((_temp1*4/146097));
  _temp1=$((_temp1-(146097*_temp2+3)/4));
  _year=$((4000*(_temp1+1)/1461001));
  _temp1=$((_temp1-1461*_year/4+31));
  _month=$((80*_temp1/2447));
  _day=$((_temp1-2447*_month/80));
  _temp1=$((_month/11));
  _month=$((_month+2-12*_temp1));
  _year=$((100*(_temp2-49)+_year+_temp1));

  export RESULT="$_year $_month $_day";
}

# Converts given formatted date to a day-based one.
function date2jd() {
  local _result=0;

  local _year=$1;
  local _month=$2;
  local _day=$3;

  local _standardJd=$(( _day - 32075
       + 1461 * (_year + 4800 - (14 - _month)/12)/4
       + 367 * (_month - 2 + (14 - _month)/12*12)/12
       - 3 * ((_year + 4900 - (14 - _month)/12)/100)/4));

  _result=$((_standardJd-2400001));

  export RESULT=${_result};
}

# Converts given date (in seconds) to a formatted date.
function jds2date() {

  local _year;
  local _month;
  local _day;
  local _hour;
  local _minute;
  local _second;

  local _jd=$1;
  jd2date $((_jd/86400));
  local _date_in_days="${RESULT}";
  _year="$(echo ${_date_in_days} | cut -d ' ' -f 1)";
  _month="$(echo ${_date_in_days} | cut -d ' ' -f 2)";
  _day="$(echo ${_date_in_days} | cut -d ' ' -f 3)";

  local _temp=$((_jd%86400));
  _hour=$((_temp/3600))
  _temp=$((_temp-_hour*3600));
  _minute=$((_temp/60));
  _second=$((_temp-_minute*60));

  export RESULT="${_date_in_days} ${_hour} ${_minute} ${_second}";
}

# Converts given formatted date to a second-based one.
function date2jds() {
  local _result=0;

  local _year=$1;
  local _month=$2;
  local _day=$3;
  local _hour=$4;
  local _minute=$5;
  local _second=$6;

  date2jd ${_year} ${_month} ${_day};
  _result=${RESULT};
  _result=$((_result*24+_hour));
  _result=$((_result*60+_minute));
  _result=$((_result*60+_second));

  export RESULT=${_result};
}

function retrieveTERM() {
  local _result="${TERM}";

  if [ "x${_result}" == "x" ]; then
    _result="dumb";
  fi

  case ${_result} in
    dumb) _result="$(uname | tr '[:upper:]' '[:lower:]')";
         ;;
      *) ;;
  esac

  export RESULT="${_result}";
}

# Retrieves the width of the term.
# Exports the value, since values greater
# than 255 are not allowed as return codes.
# <- 0: if the calculation
# <- RESULT: the term width.
function getTermWidth() {
  local -i _rescode;
  local _result;
  local _term;
  retrieveTERM;
  _term="${RESULT}";

  getTermWidthForTerm "${_term}";
  _rescode=$?;

  return ${_rescode};
}

# Retrieves the width of the term.
# Exports the value, since values greater
# than 255 are not allowed as return codes.
# -> 1: the TERM.
# <- 0: if the calculation is performed successfully.
# <- RESULT: the term width.
function getTermWidthForTerm() {
  local -i _rescode;
  local _result;
  local _term="${1}";

  $(tput cols &> /dev/null > /dev/null 2>&1) 
  _rescode=$?;

  if [ ${_rescode} -eq 0 ]; then
    _result=$(tput cols);
  fi

  if    isEmpty ${_result} \
     || [ $((_result)) -le 0 ]; then

    if ! isEmpty "${_term}"; then

      $(tput -T ${_term} cols > /dev/null 2>&1);

      if [ ${_rescode} -eq 0 ]; then
        _result=$(tput -T ${_term} cols);
      fi
    fi
  fi
  if    isEmpty ${_result} \
     || [ $((_result)) -le 0 ]; then
    _result=${_DRY_WIT_DEFAULT_TERM_WIDTH};
  fi
  export RESULT=${_result};

  return ${_rescode};
}

# Logging functions

function setLogCategoryNamespace() {
  export LOG_CATEGORY_NAMESPACE="$1";
}

function getLogCategoryNamespace() {
  export RESULT="${LOG_CATEGORY_NAMESPACE}";
}

function setLogCategory() {
  export LOG_CATEGORY="$1";
}

function getLogCategory() {
  export RESULT="${LOG_CATEGORY}";
}

## Retrieves given color.
## -> 1: The first color modifier.
## -> 2: The second color modifier (optional).
## <- RESULT: The color string.
## Example:
##   retrieveColor "setaf 2" "bold";
##   _green="${RESULT}"
function buildColor() {
  local _color="${1}";
  shift
  local _len="$#";
  local _result="";
  local _modifier;

  for _i in $(seq 1 ${_len}); do
    _modifier="${1}";
    shift;
    _result="${_result}|tput ${_modifier}";
  done
  _result="${_result#|}";

  pipe2Array "${_color}_TPUT" "${_result}";
}

declare -a BLACK_TPUT;
buildColor BLACK "setaf 0";
declare -a BLACK_B_TPUT;
buildColor BLACK_B "setaf 0" "bold";
declare -a RED_TPUT;
buildColor RED "setaf 1";
declare -a RED_B_TPUT;
buildColor RED_B "setaf 1" "bold";
declare -a RED_S_TPUT;
buildColor RED_S "setaf 1" "smul";
declare -a GREEN_TPUT;
buildColor GREEN "setaf 2" "bold";
declare -a GREEN_B_TPUT;
buildColor GREEN_B "setaf 2" "bold";
declare -a YELLOW_TPUT;
buildColor YELLOW "setaf 3";
declare -a YELLOW_B_TPUT;
buildColor YELLOW_B "setaf 3" "bold";
declare -a BLUE_TPUT;
buildColor BLUE "setaf 4";
declare -a BLUE_B_TPUT;
buildColor BLUE_B "bold" "setaf 4" "dim";
declare -a MAGENTA_TPUT;
buildColor MAGENTA "setaf 5";
declare -a MAGENTA_B_TPUT;
buildColor MAGENTA_B "setaf 5" "bold";
declare -a CYAN_TPUT;
buildColor CYAN "setaf 6";
declare -a CYAN_B_TPUT;
buildColor CYAN_B "setaf 6" "bold";
declare -a GREY_TPUT;
buildColor GREY "setaf 7";
declare -a WHITE_TPUT;
buildColor WHITE "setaf 7" "bold";
declare -a WHITE_B_TPUT;
buildColor WHITE_B "setaf 9" "bold";
declare -a NO_COLOR_TPUT;
buildColor NO_COLOR "sgr0";

export SUCCESS_COLOR=GREEN_B;
export FAILURE_COLOR=RED_B;
export IN_PROGRESS_COLOR=BLUE;
export UNDEFINED_COLOR=GREY;
export DEFAULT_LOG_PREFIX_COLOR=WHITE_B;
export DEFAULT_LOG_OUTCOME_COLOR=GREY;
export DEFAULT_LOG_RESUMING_TASK_COLOR=GREY;

export LOG_PREFIX_COLORS=(\
  BLUE   \
  CYAN  \
  RED    \
  YELLOW \
  RED \
  GREY \
  BLUE   \
);

export LOG_PREFIX_TOKENS=(\
    "[" \
    "timestamp"  \
    "<" \
    "category"  \
    ">" \
    "logLevel" \
    "]" \
);
export LOG_PREFIX_TIMESTAMP_POSITION=1;
export LOG_PREFIX_CATEGORY_POSITION=3;
export LOG_PREFIX_LEVEL_POSITION=5;

export INFO_LOG_PREFIX_TOKEN=".";
export DEBUG_LOG_PREFIX_TOKEN="o";
export TRACE_LOG_PREFIX_TOKEN="O";

export LOG_OUTCOME_COLORS=(\
    CYAN  \
    WHITE \
    CYAN  \
);

export LOG_OUTCOME_TOKENS=(\
    "[" \
    "done" \
    "]" \
);

export LOG_OUTCOME_TEXT_POSITION=1;

function allowsColors() {
  local _result;

  $(tput colors > /dev/null 2>&1);
  if isTrue $?; then
    _colors=$(tput colors);
    if [ ${_colors} -ge 8 ]; then
      env | grep -e '^_=' | grep env 2>&1 > /dev/null;
      if isTrue $?; then
        _result=${TRUE};
      else
        result=${FALSE};
      fi
    else
      _result=${FALSE};
    fi
  else
    _result=${FALSE};
  fi;

  return ${_result};
}

function getColor() {
  local _colorConstant="${1}";
  local _defaultColor="${2:${UNDEFINED_COLOR}}"
  local _result;

  if allowsColors; then
    evalConstant "${_colorConstant}" "${_defaultColor}";
    _result="${RESULT}";
  fi

  export RESULT="${_result}";
}

function findOutKeyword() {
  local _value="${1}";
  local _result;

  case "${_value}" in
    "SUCCESS") _result=${SUCCESS};
               ;;
    "FAILURE") _result=${FAILURE};
               ;;
    *) if isSuccessKeyword "${_value}"; then
         _result=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         _result=${FAILURE};
       else
         _result=${UNDEFINED};
       fi
       ;;
  esac

  return ${_result};
}

function definedTag() {
  local _result;

  case "${1}" in
    "SUCCESS" | "FAILURE") _result=${TRUE};
       ;;
    *) _result=${FALSE};
       ;;
  esac

  return ${_result};
}

function resolveVerbosity() {
  local _result="";

  if isTraceEnabled; then
    _result="-vv";
  elif isDebugEnabled; then
    _result="-v";
  elif isInfoEnabled; then
    _result="";
  fi;

  export RESULT="${_result}";
}

function isTraceEnabled() {
  local _rescode=${FALSE};

  if isDebugEnabled; then
    if [ "x${LOG_VV}" != "x" ]; then
      _rescode=${TRUE};
    fi
  fi

  return ${_rescode};
}

function setTraceEnabled() {
  LOG_VV=1;
  setDebugEnabled;
}

function logTrace() {
  if isTraceEnabled; then
    _logStuff TRACE "$@";
  fi
}

function logTraceResult() {
  if isTraceEnabled; then
    _logStuffResult TRACE "$@";
  fi
}

function logTraceFile() {
  if isTraceEnabled; then
    cat "${1}" 2> /dev/null | while IFS='' read -r line; do _logStuff TRACE "${line}"; done
  fi
}

function isDebugEnabled() {
  local _rescode=${FALSE};

  if isInfoEnabled; then
    if [ "x${LOG_V}" != "x" ]; then
      _rescode=${TRUE};
    fi
  fi

  return ${_rescode};
}

function setDebugEnabled() {
  LOG_V=1;
  setInfoEnabled;
}

function logDebugFile() {
  if isDebugEnabled; then
    cat "${1}" | while IFS='' read -r line; do _logStuff DEBUG "${line}"; done
  fi
}

function logDebug() {
  if isDebugEnabled; then
    _logStuff DEBUG "$@";
  fi
}

function logDebugResult() {
  if isDebugEnabled; then
    _logStuffResult DEBUG "$@";
  fi
}

function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

function isInfoEnabled() {
  if isTrue ${LOG_QUIET}; then
    return ${FALSE};
  else
    return ${TRUE};
  fi
}

function setInfoEnabled() {
  LOG_QUIET=${FALSE};
}

function logInfoFile() {
  if isInfoEnabled; then
    cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
  fi
}

function logInfo() {
  if isInfoEnabled; then
    _logStuff INFO "$@";
  fi
}

function logInfoResult() {
  if isInfoEnabled; then
    _logStuffResult INFO "$@";
  fi
}

function setQuietMode() {
  LOG_QUIET=${TRUE};
}

function log() {
  _logInfo "$@";
}

function logResult() {
  _logInfoResult "$@";
}

function logFile() {
  cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
}

function logWarn() {
  _internalLogStuff "false" -1 0 "$@";
}

function _logStuff() {
  local _level="${1}";
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  _logInProgress "${_level}" "$@";
  if [ "-n" != "${_minusN}" ]; then
    echo;
    _popLog;
    _popLogCategory;
  fi
}

function _logStuffResult() {
   local _level="${1}";
   shift;
  _logCompleted "${_level}" "$@";
}

## PRIVATE
## Annotates the last log message.
## -> 1: The log message.
function _setLastLog() {
  _DRY_WIT_LAST_LOG="${@}";
}

## PRIVATE
## Retrieves the last log message.
## <- RESULT: The log message.
function _getLastLog() {
  export RESULT="${_DRY_WIT_LAST_LOG}";
}

## PRIVATE
## Pushes given message to the log stack.
## -> 1: The message to push.
function _pushLog() {
  _DRY_WIT_LOG_STACK[${#_DRY_WIT_LOG_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given category to the log category stack.
## -> 1: The category to push.
function _pushLogCategory() {
    _DRY_WIT_LOG_CATEGORY_STACK[${#_DRY_WIT_LOG_CATEGORY_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given level to the log level stack.
## -> 1: The level to push.
function _pushLogLevel() {
    _DRY_WIT_LOG_LEVEL_STACK[${#_DRY_WIT_LOG_LEVEL_STACK[@]}]="$*";
}

## PRIVATE
## Retrieves the number of "in-progress" tasks pending.
## <- : Such count.
## Example:
##   _numberOfNestedInProgressTasks;
##   _count=$?
function _numberOfNestedInProgressTasks() {
  local _rescode;
  _rescode=${#_DRY_WIT_LOG_STACK[@]};
  return ${_rescode};
}

## PRIVATE
## Pops given message from the log stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped message.
## Example:
##   if _popLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _popLog() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_STACK[${_newLen}]";
    _rescode=$?;
  else
    _rescode=1;
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Peeks given message from top of the log stack.
## <- 0: if the stack contains at least the returned item; 1 otherwise.
## <- RESULT: The message.
## Example:
##   if _peekLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _peekLog() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=1;
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Pops given category from the log category stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped category.
## Example:
##   if _popLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _popLogCategory() {
    local _rescode;
    local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
    local -i _newLen;
    if [ ${_len} -gt 0 ]; then
      _newLen=$((${_len} - 1));
      export RESULT="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
      eval "unset _DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]";
      _rescode=$?;
    else
        _rescode=1;
    fi
    return ${_rescode};
}

## PRIVATE
## Peeks given category from the log category stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The category.
## Example:
##   if _peekLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _peekLogCategory() {
    local _rescode;
    local _result="";
    local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
    local -i _newLen;
    if [ ${_len} -gt 0 ]; then
      _newLen=$((${_len} - 1));
      _result="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
      _rescode=$?;
    else
        _rescode=1;
    fi
    export RESULT="${_result}";
    return ${_rescode};
}

## PRIVATE
## Pops given level from the log level stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped level.
## Example:
##   if _popLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _popLogLevel() {
    local _rescode;
    local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
    local -i _newLen;
    if [ ${_len} -gt 0 ]; then
      _newLen=$((${_len} - 1));
      export RESULT="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
      eval "unset _DRY_WIT_LOG_LEVEL_STACK[${_newLen}]";
      _rescode=$?;
    else
        _rescode=1;
    fi
    return ${_rescode};
}

## PRIVATE
## Peeks given level from the log level stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The level.
## Example:
##   if _peekLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _peekLogLevel() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=1;
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Checks whether the log line is currently opened.
## <- 0: if it's open; 1 otherwise.
## Example:
##   if _isLogLineOpen; then [..]; fi
function _isLogLineOpen() {
  return ${_DRY_WIT_LOG_LINE_OPEN};
}

## PRIVATE
## Opens the log line.
## Example:
##   _openLogLine;
function _openLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${TRUE};
}

## PRIVATE
## Closes the log line.
## Example:
##   _closeLogLine;
function _closeLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
}

## PRIVATE
## Retrieves the timestamp used for logging.
## <- RESULT: The timestamp.
## Note: Override LOG_TIMESTAMP to modify the timestamp format.
## Example:
##   _retrieveLogTimestamp;
##   echo "The log timestamp is ${RESULT}";
function _retrieveLogTimestamp() {
  export RESULT="$(date "${LOG_TIMESTAMP}")";
}

## PRIVATE
## Retrieves the position of the timestamp in
## the log prefix tokens array.
## <- RESULT: the timestamp position.
## Example:
##   _retrieveTimestampPositionInLogPrefix;
##   echo "timestamp -> ${RESULT}";
function _retrieveTimestampPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_TIMESTAMP_POSITION};
}

## PRIVATE
## Retrieves the position of the category in
## the log prefix tokens array.
## <- RESULT: the category position.
## Example:
##   _retrieveCategoryPositionInLogPrefix;
##   echo "category -> ${RESULT}";
function _retrieveCategoryPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_CATEGORY_POSITION};
}

## PRIVATE
## Retrieves the position of the log level in
## the log prefix tokens array.
## <- RESULT: the level position.
## Example:
##   _retrieveLevelPositionInLogPrefix;
##   echo "level -> ${RESULT}";
function _retrieveLevelPositionInLogPrefix() {
    export RESULT=${LOG_PREFIX_LEVEL_POSITION};
}

## PRIVATE
## Retrieves the position of the outcome token in
## the log outcome colors array.
## <- RESULT: the outcome text position.
## Example:
##   _retrieveOutcomeTextPositionInLogOutcome;
##   echo "outcome text -> ${RESULT}";
function _retrieveOutcomeTextPositionInLogOutcome() {
  export RESULT=${LOG_OUTCOME_TEXT_POSITION};
}

## PRIVATE
## Retrieves the tokens composing the log prefix.
## -> 1: The log category.
## -> 2: The log level (optional).
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_PREFIX_TOKENS array.
## Example:
##    _retrieveLogPrefixTokens "a:b:c" DEBUG;
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_PREFIX_TOKENS[*]}"
function  _retrieveLogPrefixTokens() {
  local _category="${1}";
  local _levelVar="${2}";
  evalConstant "${_levelVar}_LOG_PREFIX_TOKEN" "${INFO_LOG_PREFIX_TOKEN}";
  local _level="${RESULT}";
  local _result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  _len=$((${#LOG_PREFIX_TOKENS[@]} - 1));
  for _i in $(seq 0 ${_len}); do
    _aux="${_aux}|${LOG_PREFIX_TOKENS[${_i}]}";
  done
  _aux="${_aux#|}";
  pipe2Array _DRY_WIT_LOG_PREFIX_TOKENS "${_aux}";

  _retrieveLogTimestamp;
  _timestamp="${RESULT}";
  _retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_timestampPosition}]="${_timestamp}";
  _retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_categoryPosition}]="${_category}";
  _retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_levelPosition}]="${_level}";
}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The outcome text.
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_TOKENS array.
## Example:
##    _retrieveLogOutcomeTokens "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_TOKENS[*]}"
function  _retrieveLogOutcomeTokens() {
  local _text="${1}";
  local _result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_TOKENS[@]} - 1));
  for _i in $(seq 0 ${_len}); do
    _aux="${_aux}|${LOG_OUTCOME_TOKENS[${_i}]}";
  done
  _aux="${_aux#|}";
  pipe2Array "_DRY_WIT_LOG_OUTCOME_TOKENS" "${_aux}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_TOKENS[${_outcomeTextPosition}]="${_text}";

}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_COLORS array.
## Example:
##    _retrieveLogOutcomeColors SUCCESS "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_COLORS[*]}"
function  _retrieveLogOutcomeColors() {
  local _keyword="${1}";
  local _result=();
  local _aux="";
  _retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_COLORS[@]} - 1));
  for _i in $(seq 0 ${_len}); do
    _aux="${_aux}|${LOG_OUTCOME_COLORS[${_i}]}";
  done
  _aux="${_aux#|}";
  pipe2Array "_DRY_WIT_LOG_OUTCOME_COLORS" "${_aux}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_COLORS[${_outcomeTextPosition}]="${_keywordColor}";
}

## PRIVATE
## Retrieves the color for a given keyword.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## -> 2: The default color.
## <- RESULT: The associated color.
## Example:
##   _retrieveKeywordColor SUCCESS GREEN;
##   echo "Color -> ${RESULT}"
function _retrieveKeywordColor() {
  local _keyword="${1}";
  local _defaultColor="${2}";

  local _result;

  case ${_keyword} in
      SUCCESS | "${SUCCESS}") _result="${SUCCESS_COLOR}";
                              ;;
      FAILURE | "${FAILURE}" | "FAILED" | "failed" | "FAIL" | "fail") _result="${FAILURE_COLOR}";
                                                                      ;;
      IN_PROGRESS | "${IN_PROGRESS}") _result="${IN_PROGRESS_COLOR}";
                                      ;;
      *) _result="${_defaultColor}";
         ;;
  esac

  export RESULT="${_result}";
}

## PRIVATE
## Prints the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _echoLogPrefix "cat" DEBUG
function _echoLogPrefix() {
  local _category="${1}";
  local _level="${2}";
  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  _echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

## PRIVATE
## Retrieves the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _retrieveLogPrefix "cat" DEBUG;
##   echo "log prefix -> ${RESULT}";
function _retrieveLogPrefix() {
  local _category="${1}";
  local _level="${2}";
  local _result="$(_echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${_result}";
}

## PRIVATE
## Prints the log prefix, for color terminals.
## -> 1: The log category.
## -> 2: ${TRUE} if using colors; ${FALSE} otherwise.
## -> 3: The log level.
## Example:
##   _echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function _echoColorAwareLogPrefix() {
  local _category="${1}";
  local _allowsColors=${2};
  local _level="${3}";
  local _len;
  local _colors;

  _retrieveLogPrefixTokens "${_category}" "${_level}";
#  source ${RESULT};

  _len=$((${#_DRY_WIT_LOG_PREFIX_TOKENS[@]} - 1));
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${LOG_PREFIX_COLORS[${_i}]}" "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    fi
  done

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
}

## PRIVATE
## Retrieves the log namespace.
## <- RESULT: The log namespace.
function _retrieveLogNamespace() {
  local _namespace="${LOG_CATEGORY_NAMESPACE}";
  local _category="${LOG_CATEGORY}";

  if isEmpty "${_namespace}"; then
    if isEmpty "${SCRIPT_NAME}" ; then
      _result="?";
    else
      _result="$(basename ${SCRIPT_NAME} .sh)";
    fi
  fi

  if ! isEmpty ${_category} ; then
    _result="${_result}:${_category}";
  fi

  export RESULT="${_result}";
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcome() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift;
  local _text="${@}";
  local _len;
  local _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;

  _retrieveLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    _retrieveLogOutcomeColors ${_keyword};
  fi

  _peekLog;
  _inProgressMessage="${RESULT}";
  _peekLogCategory;
  _category="${RESULT}";
  _peekLogLevel;
  _level="${RESULT}";
  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  _len=$((${#_DRY_WIT_LOG_OUTCOME_TOKENS[@]} - 1));
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_DRY_WIT_LOG_OUTCOME_COLORS[${_i}]}" "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    fi
  done

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcomeNested() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift;
  local _text="${@}";
  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  _popLog;
  _inProgressMessage="${RESULT}";
  _popLogCategory;
  _category="${RESULT}";
  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  for _i in $(seq 1 ${_nestedTasks}); do
    _indentation="${_indentation}${LOG_NESTED_INDENTATION}";
  done
  _pushLog "${_indentation}${_inProgressMessage}";
  _pushLogCategory "${_category}";
}

## PRIVATE
## Writes spaces until the next message to print
## is aligned to the right.
## -> 1: The log-line message.
## -> 2: The log outcome message.
## Example:
##  _alignRight "Finishing work" "done";
function _alignRight() {
  local _logLineMessage="${1}";
  local _outcome="${2}";
  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;

  _retrieveLogOutcomeTokens "${_outcome}";
  for _token in "${_DRY_WIT_LOG_OUTCOME_TOKENS[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done

  getTermWidth;
  if isTrue $?; then
    _termWidth=$RESULT;
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${LOG_OUTCOME_SEPARATOR}";
    done
  fi
}

## PUBLIC
## Prints a text in color.
## -> 1: -n : Whether to remove the CRLF from the end (optional).
## -> 2: The color.
## -> 3: The text to echo.
function echoInColor() {
  local _flagMinusN;
  local _colorAux;
  if [ "${1}" == "-n" ]; then
    _flagMinusN=${TRUE};
    shift;
  else
    _flagMinusN=${FALSE};
  fi
  local _color="${1}";
  local _text="${2}";

  if ! isEmpty "${_color}_TPUT"; then
    flattenArray "${_color}_TPUT" " && ";
    _colorAux="${RESULT}";
#    echo "${BLUE_TPUT}, coloraux -> ${_colorAux}"
  fi
  if isTrue ${_flagMinusN}; then
    echo -n "$(${_colorAux})${_text}";
#    echo -n "${_text}";
  else
    echo "$(${_colorAux})${_text}";
#    echo "${_text}";
  fi
}

## PUBLIC
## Prints a text in color.
## -> 1: -n : Whether to remove the CRLF from the end (optional).
## -> 2: The color.
## -> 3: The text to echo.
function resetColor() {
  ${NO_COLOR};
}

## PUBLIC
## Echoes given text, colorized.
## -> 1: The text to colorize.
## -> 2: The keyword (0 -> success; 1 -> failure; other -> try to infer from the text).
## -> 3: The default color (optional).
## Example:
##   echoColorizeText "done" SUCCESS;
function echoColorizedText() {
  local _text="${1}";
  local _keyword="${2}";
  local _defaultColor="${3:${UNDEFINED_COLOR}}";
  local _color="";
  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    getColor ${_defaultColor};
    _undefinedColor="${RESULT}";
    getColor ${SUCCESS_COLOR};
    _successColor="${RESULT}";
    getColor ${FAILURE_COLOR};
    _failureColor="${RESULT}";
    case ${_keyword} in
      ${SUCCESS}) _color="${_successColor}";
         ;;
      ${FAILURE}) _color="${_failureColor}";
         ;;
      *) if isSuccessKeyword "${_text}"; then
           _color="${_successColor}";
         elif isFailureKeyword "${_text}"; then
           _color="${_failureColor}";
         else
           _color="${_undefinedColor}";
         fi
         ;;
    esac
  fi
  echoColorizedTextWithColor -n "${_color}" "${_text}";
}

## PUBLIC
## Echoes given text, colorized.
## -> 1: The text to colorize.
## -> 2: The text color.
## Example:
##   echoColorizeTextWithColor "${WHITE}" "done";
function echoColorizedTextWithColor() {
  local _flagMinusN;
  if [ "${1}" == "-n" ]; then
    _flagMinusN=${TRUE};
    shift;
  else
    _flagMinusN=${FALSE};
  fi
  evalConstant "${1}";
  local _color="${RESULT}";
  local _text="${2}";
  local _result;

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    if isTrue ${_flagMinusN}; then
      echoInColor -n "${_color}" "${_text}";
    else
      echoInColor "${_color}" "${_text}";
    fi
    resetColor;
  elif isTrue ${_flagMinusN}; then
    echo -n "${_text}";
  else
    echo "${_text}";
  fi
}

## PRIVATE
## Prints a log message.
## -> 1: The log level.
## -> 2: The message.
## Example:
##   _logMessage INFO "A message to log"
##   # [...] A message to log
function _logMessage() {
  local _level="${1}";
  shift;
  local _message="$@";
  _logInProgress "${_level}" "${_message}";
  echo;
}

## PRIVATE
## Prints a log message, indicating some uncompleted task.
## -> 1: The message.
## Example:
##   _logInProgress "Calculating ...";
##   # [...] Calculating ...
function _logInProgress() {
  local _level="${1}";
  shift;
  local _message="$@";
  local -i nestedTasks;
  local _category;
  _retrieveLogNamespace;
  _category="${RESULT}";

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
    _logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    _logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're nested tasks.
## -> 1: The category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logInProgressNested "cat" DEBUG "Calculating ...";
##   # [...<cat>|o] Calculating ...
function _logInProgressNested() {
  local _category="${1}";
  shift;
  local _level="${1}";
  shift;
  local _message="$@";
  local _logPrefix;
  _pushLog "${_message}";
  _pushLogCategory "${_category}";
  _pushLogLevel "${_level}";
  _logCompletedNestedNoPop "${_level}" IN_PROGRESS "${NESTED_TASK_IN_PROGRESS}";
  echo;

  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _echoLogPrefix "${_category}" "${_level}";
  _peekLog;
  _actualMessage="${RESULT}";
  echoColorizedText "${_actualMessage}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're no nested tasks.
## -> 1: The log category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logProgressNoNested "cat" INFO "Calculating ...";
##   # [...<cat|.>] Calculating ...
function _logInProgressNoNested() {
  local _category="${1}";
  shift;
  local _level="${1}";
  shift;
  local _message="$@";
  local _logPrefix;

  _logPrefix="${RESULT}";
  _pushLogCategory "${_category}";
  _pushLog "${_message}";
  _pushLogLevel "${_level}";
  _retrieveLogPrefix "${_category}" "${_level}";
  _echoLogPrefix "${_category}" "${_level}";
  echoColorizedText "${_message}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompleted INFO SUCCESS "done";
function _logCompleted() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift;
  local _text="${@}";
  local -i nestedTasks;

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    _logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    _logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNoNested INFO SUCCESS "done";
function _logCompletedNoNested() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift;
  local _text="${@}";
  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _popLog;
  _popLogCategory;
  _popLogLevel;
  echo;
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested INFO SUCCESS "done";
function _logCompletedNested() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift
  local _message="$@";
  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  _echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  _popLogCategory;
  _peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  _popLogLevel;
  _peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  _popLog;
  _peekLog;
  _nestedTask="${RESULT}";
  _echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  echoColorizedText "${_nestedTask}" "" "${DEFAULT_LOG_RESUMING_TASK_COLOR}";
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested SUCCESS "done";
function _logCompletedNestedNoPop() {
  local _level="${1}";
  shift;
  local _keyword="${1}";
  shift
  local _message="$@";
  _echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}

function urlEncode() {
  local _text="$1";

    echo "${_text}"  \
  | sed 's % %25 g'  \
  | sed 's \+ %2B g' \
  | sed 's| |+|g'    \
  | sed 's \[\[BR\]\] %0D%0A g' \
  | sed 's ! %21 g'  \
  | sed 's \* %2A g' \
  | sed "s ' %27 g" \
  | sed 's ( %28 g'  \
  | sed 's ) %29 g'  \
  | sed 's ; %3B g'  \
  | sed 's : %3A g'  \
  | sed 's @ %40 g'  \
  | sed 's & %26 g'  \
  | sed 's = %3D g'  \
  | sed 's \$ %24 g' \
  | sed 's , %2C g'  \
  | sed 's / %2F g'  \
  | sed 's \? %3F g' \
  | sed 's \[ %5B g' \
  | sed 's \] %5D g';

#  !    *    '    (    )    ;    :    @    &    =    +    $    ,    /
#%21  %2A  %27  %28  %29  %3B  %3A  %40  %26  %3D  %2B  %24  %2C  %2F
#  ?    %    #    [    ]
# %3F  %25  %23  %5B  %5D
}

function readConfFile() {
  local _confFile="${1}";
  local result=${TRUE};

  [ ! -e "${_confFile}" ] && result=${FALSE};

  local _actualConfFile="${_confFile}";

  createTempFile;
  result=$?;

  if isFalse ${result}; then
    return ${result};
  fi

  _actualConfFile="${RESULT}";

    grep -v '^#' "${_confFile}" | sed 's ${\(.*\)} _dollar{\1}_ g' \
  | sed 's ^\(.*\)=\(.*\) echo\ -n\ \1\ |\ tr\ \[:lower:\]\ \[:upper:]\;\ echo\ -n\ =\;\ echo\ \2 g' \
  | sh \
  | sed 's _dollar{\(.*\)}_ ${\1} g' \
  | sed 's_^\(.*\)=\(.*\)$_\1=\2; logTrace \1=\${\1};_ g' \
  | sed 's_^_export _g' > "${_actualConfFile}";

  . "${_actualConfFile}";

  return ${result};
}

function checkPasswordlessSudo() {
  local _result=${TRUE};

  which sudo 2>&1 > /dev/null;
  _result=$?;

  if [ ${_result} == 0 ]; then
    local _tmp="${TEMP}";
    if [ ! -r "${_tmp}" ]; then
      _tmp="/tmp";
    fi
    if [ ! -r "${_tmp}" ]; then
      _tmp="$PWD";
    fi
    if [ -r "${_tmp}" ]; then
      echo "" | sudo -S sudo ls "${_tmp}" 2> /dev/null > /dev/null
      _result=$?;
    else
      _result=1;
    fi
  fi

  return ${_result};
}

function findRelativePathBetweenFolders() {
  # Given two paths, A and B, find the shortest way
  # to reach B from A.
  # For example, if A is /tmp/test and B is /tmp/my/private/temp,
  # the shortest path is ../my/private/temp.
  # The algorith is as follows:
  # 1) Find the greatest common parent to A and B -> parent
  # 2) Remove 'parent' from A and B -> A* and B*
  # 3) Find out the distance from A to A* -> d
  # 4) Replace the greatest 'd' parent folders with '..' in A -> P*
  # 5) Result=P*/B*
  local _pathA="$1";
  local _pathB="$2";
  local _parent;
  local _pathAb;
  local _pathBb;
  local _d;
  local _p;
  local _result;

  findGreatestCommonParentFolder "${_pathA}" "${_pathB}";
  _parent="${RESULT}";

  _pathAb="${_pathA#${_parent}}";
  _pathAb="${_pathAb#/}";
  _pathBb="${_pathB#${_parent}}";
  _pathBb="${_pathBb#/}";

  findFolderDistance "${_pathA}" "${_pathAb}";
  _d="${RESULT}";
  index=0;

  replaceNLeftmostTokens "${_pathA}" ".." ${_d} "/";
  _p="${RESULT}";
  local _aux=$(echo ${_pathA} | awk -F"/" '{print NF;};');
  replaceNRightmostTokens "${_p}" "" $((_aux-_d-1)) "/";
  _p="${RESULT}";

  _result="${_p}/${_pathBb}";

  export RESULT="${_result}";
}

function findGreatestCommonParentFolder() {
  local _pathA="$1";
  local _pathB="$2";
  local _result="";

  local _maxA=$(echo "${_pathA}" | awk -F"/" '{print NF;}');
  local _maxB=$(echo "${_pathB}" | awk -F"/" '{print NF;}');
  local _max=$((_maxA));
  if [ $((_max)) -lt $((_maxB)) ]; then
    _max=$((_maxB));
  fi

  local _index=1;
  local _auxA;
  local _auxB;

  while [ $((_index)) -le $((_max)) ]; do
    _auxA=$(echo "${_pathA}" | awk -F"/" -vindx=${_index} '{printf("%s", $indx);}');
    _auxB=$(echo "${_pathB}" | awk -F"/" -vindx=${_index} '{printf("%s", $indx);}');
    _index=$((_index+1));
    if [ "${_auxA}" == "${_auxB}" ]; then
      _result="${_result}/${_auxA}";
    else
      break;
    fi
  done

  _result=$(echo "${_result}" | sed 's ^/  g');

  export RESULT="${_result}";
}

function findFolderDistance() {
  local _pathA="$1";
  local _pathB="$2";
  local _result=-1;

  local _maxA=$(echo "${_pathA}" | awk -F"/" '{print NF;}');
  local _maxB=$(echo "${_pathB}" | awk -F"/" '{print NF;}');
  local _max=$((_maxA));
  if [ $((_max)) -lt $((_maxB)) ]; then
    _max=$((_maxB));
  fi

  local _index=$((_max));
  local _indexA=$((_maxA));
  local _indexB=$((_maxB));
  local _auxA;
  local _auxB;

  while [ $((_index)) -gt 0 ]; do
    _indexA=$((_maxA-_max+_index));
    _indexB=$((_maxB-_max+_index));
    if    [ $((_indexA)) -eq 0 ] \
       || [ $((_indexB)) -eq 0 ]; then
      _result=$((_max-_index));
      break;
    fi
    _auxA=$(echo "${_pathA}" | awk -F"/" -vindx=${_indexA} '{printf("%s", $indx);}');
    _auxB=$(echo "${_pathB}" | awk -F"/" -vindx=${_indexB} '{printf("%s", $indx);}');
    _index=$((_index-1));
    if [ "${_auxA}" != "${_auxB}" ]; then
      _result=${TRUE};
      break;
    fi
  done

#  if [ $((_result)) -ge 0 ]; then
#    _result=$((_max-_result));
#  else
#    _result=${TRUE};
#  fi

  export RESULT="${_result}";
}

function replaceNLeftmostTokens() {
  local _text="$1";
  local _newToken="$2";
  local _number=$(($3));
  local _separator="$4";
  local _result=$(echo "${_text}" | awk -F"${_separator}" -vd=${_number} -vnewT="${_newToken}" -vseparator="${_separator}" '{for (i=0;i<d&&i<NF;i++) {printf("%s%s", newT, separator);}for (i=d+2;i<=NF;i++){printf("%s%s", $i, separator);}}END{printf("\n");}' | sed "s ${_separator}$  g");
  export RESULT="${_result}";
}

function replaceNRightmostTokens() {
  local _text="$1";
  local _newToken="$2";
  local _number=$(($3));
  local _separator="$4";
  local _result=$(echo "${_text}" | awk -F"${_separator}" -vd=${_number} -vnewT="${_newToken}" -vseparator="${_separator}" '{for (i=NF;i>NF-d&&i>0;i--) {if (newT!="") {printf("%s%s", newT, separator);}}for (i=NF-d;i>0;i--){printf("%s%s", $i, separator);}}END{printf("\n");}' | sed "s ${_separator}$  g");
  export RESULT="${_result}";
}

###
 # Uncompresses given file to a concrete folder.
 # @param 1 the file.
 # @param 2 the output folder.
 # @return 0: No error.
 # @return 1: Invalid file format.
 # @return 2: Error uncompressing file.
##
function uncompress() {
  local _file="${1}";
  local _destination="${2}";
  local _result=${TRUE};

  createTempFile;
  local _errorOutput="${RESULT}";

  local _flags;

  # First, check whether the bundle is compressed bzip2 format.
  if file "${_file}" | cut -d ":" -f 2 | grep bzip2 2>&1 > /dev/null; then
    _flags="xfj";
  # Second try: check whether the bundle is compressed gzip format.
  elif file "${_file}" | cut -d ":" -f 2 | grep gzip 2>&1 > /dev/null; then
    _flags="xfz";
  # Otherwise, it can also be a standard, uncompressed tar.
  elif file "${_file}" | cut -d ":" -f 2 | grep tar 2>&1 > /dev/null; then
    _flags="xf";
  else
    _result=1;
  fi

  if [ ${_result} == 0 ]; then
    logInfo -n "Uncompressing ${_file}";
    tar ${_flags} "${_file}" -C "${_destination}" 2>&1 > "${_errorOutput}";
    if [ $? == 0 ]; then
      logInfoResult "Done";
    else
      logInfoResult "Failed";
      logDebugFile "${_errorOutput}";
      _result=2;
    fi
  fi

  return ${_result};
}

function removeExtension() {
  local _file="$1";
  local _result="$(basename ${_file}$)";
  _result="${_result%.*}";

  export RESULT="${_result}";
}

function remoteSshCommand() {
  local _result;
  local _resultCode=${TRUE};
  local _user="$1";
  local _server="$2";
  local _command="$3";

  _result=$(ssh ${_user}@${_server} "${_command}" 2> /dev/null);
  _resultCode=$?;
  if [ ${_resultCode} == 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_resultCode};
}

# Retrieves the disk space available in the filesystem containing
# given folder. Prints the available space in bytes. Returns 0 if
# the space could be calculated.
# - folder: the folder.
function retrieveFreeDiskSpaceUnderFolder() {
  local _result;
  local _resultCode=1;
  local _folder="$1";
  local _aux="${_folder}";

  if [ -d "${_folder}" ]; then
    while [ "x${_aux}" != "x" -a "x${_aux}" != "x/" ] && \
          ! mountpoint -q "${_aux}"; do
      _aux="${_aux%/*}";
    done;

    mountpoint -q "${_aux}";
    _resultCode=$?;

    if [ ${_resultCode} -eq 0 ]; then
      _result="$(df | grep " ${_aux}$" | awk '{print $4;}')";
      _resultCode=$?;
    fi
  fi

  export RESULT="${_result}";

  return ${_resultCode};
}

function remoteSshCommandPipe() {
  local _result;
  local _resultCode=${TRUE};
  local _user="$1";
  local _server="$2";
  local _command="$3";
  shift;
  shift;
  shift;
  local _previousPipe="$@";

  echo "_previousPipe=${_previousPipe}";
  echo "_command=${_command}";
  _result=$(${_previousPipe} | while IFS='' read -r line; do echo ${line} | ssh "${_user}@${_server}" "${_command}"; done);
  _resultCode=$?;
  if [ ${_resultCode} == 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_resultCode};
}

# Runs a command supporting logging of command-line and output.
# The output is stored in a single variable. If it's expected to
# be longer use 'runCommandLongOutput' instead.
# Parameters:
# - Command: The command to run.
function runCommand() {
  local _command="$(echo $@ | sed 's_\n_ _g')";
  local _result;
  local _resultCode;

  getLogCategory;
  local _previousLogCategory="${RESULT}";
  setLogCategory "${_previousLogCategory}:($1)";

  logDebug "${_command}";
  _result=$($@ 2>&1);
  _resultCode=$?;

  export RESULT="${_result}";

  setLogCategory "${_previousLogCategory}";
  return ${_resultCode};
}

# Runs a command supporting logging of command-line and output,
# even if it's long, since it uses a temporary file to store it.
# Parameters:
# - Command: The command to run.
function runCommandLongOutput() {
  local _command="$(echo $@ | sed 's_\n_ _g')";
  local _result;
  local _resultCode;

  createTempFile;
  _result="${RESULT}";

  getLogCategory;
  local _previousLogCategory="${RESULT}";
  setLogCategory "${_previousLogCategory}:($1)";

  logDebug "${_command}";

  if isDebugEnabled; then
    $@ 2>&1 | tee "${_result}";
    _resultCode=${PIPESTATUS[0]};
  else
    $@ > "${_result}" 2>&1;
    _resultCode=$?;
  fi

  export RESULT="${_result}";

  setLogCategory "${_previousLogCategory}";

  return ${_resultCode};
}

function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

## Retrieves the absolute path of given argument.
## -> 1: The relative path.
## <- RESULT: The absolute path.
function _retrieveAbsolutePath() {
  local _relativePath="${1}";
  export RESULT="$(readlink -f "${_relativePath}")";
}

function _functionPresent() {
  local _function=$1;
  local _script=$2;
  type ${_function} 2> /dev/null | grep -q 'shell function'
  local _rescode=$?;
  if [ ${_rescode} -ne 0 ]; then
    grep " ${_function}()" "${_script}" 2>&1 > /dev/null
    _rescode=$?;
  fi
  if [ ${_rescode} -ne 0 ]; then
    for _inc in "./$(basename ${_script} .sh).inc.sh" \
                "${DRY_WIT_SCRIPT_FOLDER}/$(basename ${_script} .sh).inc.sh"; do
      if [ -e "${_inc}" ]; then
        _functionPresent "${_function}" "${_inc}";
        _rescode=$?;
	if [ ${_rescode} -eq 0 ]; then
	  break;
	fi
      fi
    done
  fi
  return ${_rescode};
}

function _parseCommonInput() {

  local _help=${TRUE};
  setInfoEnabled;

  local _flags=$(extractFlags $@);
  local _flagCount;
  for _flag in ${_flags}; do
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help)
         _help=1;
         ;;
      -v)
         setDebugEnabled;
         ;;
      -vv)
         setTraceEnabled;
         ;;
      -q)
         setQuietMode;
         ;;
      -X:e | --X:eval-defaults)
          export DRY_WIT_EVAL_DEFAULTS_FLAG=1;
         ;;
    esac
  done
  shift ${_flagCount};

  export DRY_WIT_HELP_FLAG=${_help};
}

function _checkCommonInput() {

  if [ ${DRY_WIT_HELP_FLAG} == 1 ]; then
    _printHelp;
    exit 0;
  fi
}

function _checkScript() {
  local _script=$1;
  local v;
  local f;

  setLogCategory "sanity-check";
  logTrace -n "Checking mandatory constants";
  for v in ERROR_MESSAGES; do
    if [ "x${v}" == "x" ]; then
      exitWithErrorCode MISSING_MANDATORY_VARIABLES $v;
    fi
  done
  logTraceResult SUCCESS "Done";

  logTrace -n "Checking mandatory functions";
  for f in usage main; do
    _functionPresent $f $_script;
    if [ $? != 0 ]; then
      exitWithErrorCode MISSING_MANDATORY_FUNCTIONS $f;
    fi
  done
  logTraceResult SUCCESS "Done";
}

function _setup() {
  _trapSignals;
  [ -e "${DRY_WIT_SCRIPT_FOLDER}/$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" ] && \
      source "${DRY_WIT_SCRIPT_FOLDER}/$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh";
  [ -e "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" ] && \
      source "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh";
  [ -e "${DRY_WIT_SCRIPT_FOLDER}/.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" ] && \
      source "${DRY_WIT_SCRIPT_FOLDER}/.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh"
  [ -e "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" ] && \
      source "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh"
  evalEnvVars;
}

if [ "$1" != "" ]; then
  export SCRIPT_NAME="$(basename $1)";
else
  export SCRIPT_NAME="$0";
fi

function _main() {
  local _script="${1#./}";
  shift;
  local _absolutePath;
  _retrieveAbsolutePath "${_script}";
  export DRY_WIT_SCRIPT_PATH="${RESULT}";
  export DRY_WIT_SCRIPT_FOLDER="$(dirname ${DRY_WIT_SCRIPT_PATH})";

  _setup "${_script}";

  if _functionPresent defineErrors "${_script}"; then
    defineErrors;
  else
    export ERROR_MESSAGES=();
  fi

  if _functionPresent defineEnvDefaults "${_script}"; then
    defineEnvDefaults;
  fi

  if _functionPresent defineEnv "${_script}"; then
    defineEnv;
  fi

  if _functionPresent defineKeywords "${_script}"; then
    defineKeywords;
  fi

  _parseCommonInput $@;

  if _functionPresent parseInput "${_script}"; then
    evalEnvVars;
    parseInput $@;
  fi

  _checkCommonInput $@;

  _checkScript "${_script}";

  if _functionPresent checkRequirements "${_script}"; then
    logTrace -n "Checking declared requirements";
    checkRequirements;
    logTraceResult SUCCESS "Done";
  fi

  if _functionPresent checkInput "${_script}"; then
    evalEnvVars;
    checkInput $@;

    if _functionPresent postCheckInput "${_script}"; then
      postCheckInput $@;
    fi
  fi

  setLogCategory "main";
  main;
}

source $@;
_main $@;
cleanup;
