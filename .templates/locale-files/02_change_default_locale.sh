#!/bin/bash dry-wit
# Copyright 2015-today Automated Computing Machinery S.L.
# Distributed under the terms of the GNU General Public License v3

function usage() {
cat <<EOF
$SCRIPT_NAME locale encoding
$SCRIPT_NAME [-h|--help]
(c) 2016-today Automated Computing Machinery S.L.
    Distributed under the terms of the GNU General Public License v3

Changes the locale and encoding (available after re-login).

Where:
  - locale: The locale to use.
  - encoding: The encoding to use.

Common flags:
    * -h | --help: Display this message.
    * -v: Increase the verbosity.
    * -vv: Increase the verbosity further.
    * -q | --quiet: Be silent.
EOF
}

# Requirements
function defineRequirements() {
  checkReq locale-gen;
}

## Defines the errors
## dry-wit hook
function defineErrors() {
  addError "INVALID_OPTION" "Unrecognized option";
  addError "LOCALE_IS_MANDATORY" "The locale parameter is mandatory";
  addError "ENCODING_IS_MANDATORY" "The encoding parameter is mandatory";
}

## Validates the input.
## dry-wit hook
function checkInput() {

  local _flags=$(extractFlags $@);
  local _flagCount;
  local _currentCount;
  logDebug -n "Checking input";

  # Flags
  for _flag in ${_flags}; do
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help | -v | -vv | -q)
         shift;
         ;;
      *) logDebugResult FAILURE "failed";
         exitWithErrorCode INVALID_OPTION;
         ;;
    esac
  done

  if isEmpty "${LOCALE}" && isEmpty ${DEFAULT_LOCALE}; then
    logDebugResult FAILURE "failed";
    exitWithErrorCode LOCALE_IS_MANDATORY;
  elif isEmpty "${ENCODING}" && isEmpty ${DEFAULT_ENCODING}; then
      logDebugResult FAILURE "failed";
      exitWithErrorCode ENCODING_IS_MANDATORY;
  else
    logDebugResult SUCCESS "valid";
  fi
}

## Parses the input
## dry-wit hook
function parseInput() {

  local _flags=$(extractFlags $@);
  local _flagCount;
  local _currentCount;

  # Flags
  for _flag in ${_flags}; do
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help | -v | -vv | -q)
         shift;
         ;;
    esac
  done

  if isEmpty "${LOCALE}"; then
      LOCALE="${1}";
      shift;
  fi
  if isEmpty "${LOCALE}"; then
      LOCALE="${DEFAULT_LOCALE}";
  fi
  if isEmpty "${ENCODING}"; then
      ENCODING="${1}";
  fi
  if isEmpty "${ENCODING}"; then
      ENCODING="${DEFAULT_ENCODING}";
  fi
}

## Changes the default locale.
## -> 1: The locale.
## Example:
##   change_default_locale "en_US.UTF-8"
function change_default_locale() {
  local _locale="${1}";
  local _encoding="${2}";
  local _lang="${_locale%_*}";
  local _country="${_locale#*_}";
  _country="${_country%@*}";

  logInfo -n "Modifying ${DEFAULTLOCALE_FILE}";
  echo "LANG=\"${_lang}_${_country}.${_encoding}\"" > ${DEFAULTLOCALE_FILE};
  echo "LANGUAGE=\"${_lang}_${_country}\"" >> ${DEFAULTLOCALE_FILE};
  echo "LC_ALL=\"${_lang}_${_country}.${_encoding}\"" >> ${DEFAULTLOCALE_FILE};
  logInfoResult SUCCESS "done";

  logInfo -n "Modifying ${BASHLOCALE_FILE}";
  echo "# Generated by ${SCRIPT_NAME} for locale ${_locale} ${_encoding}" > ${BASHLOCALE_FILE};
  echo "export LANG=\"${_locale}.${_encoding}\"" >> ${BASHLOCALE_FILE};
  echo "export LANGUAGE=\"${_locale}_${_country}\"" >> ${BASHLOCALE_FILE};
  echo "export LC_ALL=\"${_lang}_${_country}.${_encoding}\"" >> ${BASHLOCALE_FILE};
  #  echo "export LC_CTYPE=\"${_lang}_${_country}.${_encoding}\"" >> ${BASHLOCALE_FILE};
  logInfoResult SUCCESS "done";
}

## Main logic
## dry-wit hook
function main() {
  change_default_locale "${LOCALE}" "${ENCODING}";
}
